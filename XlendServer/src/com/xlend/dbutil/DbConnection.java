/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.xlend.dbutil;

import com.xlend.XlendServer;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.rmi.RemoteException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Locale;
import java.util.Properties;

/**
 *
 * @author Nick Mukhin
 */
public class DbConnection {

    private static final int DB_VERSION_ID = 6;
    public static final String DB_VERSION = "0.06";
    private static boolean isFirstTime = true;
    private static Properties props = new Properties();
    private static String[] createLocalDBsqls = loadDDLscript("crebas_hsqldb.sql");
    private static String[] fixLocalDBsqls = new String[]{
        "update dbversion set version_id = " + DB_VERSION_ID + ",version = '" + DB_VERSION + "'",
        //version 0.2->0.3
        "alter table xclient add description varchar(255)",
        "create cached table xcontract"
        + "("
        + "    xcontract_id   int generated by default as identity (start with 1),"
        + "    contractref    varchar(32) not null,"
        + "    description    varchar(255),"
        + "    xclient_id     int not null,"
        + "    picture_id     int,"
        + "    constraint xcontract_pk primary key (xcontract_id),"
        + "    constraint xcontract_xclient_fk foreign key (xclient_id) references xclient,"
        + "    constraint xcontact_picture_fk foreign key (picture_id) references picture"
        + ")",
        //version 0.3->0.4
        "alter table xcontract drop constraint xcontact_picture_fk",
        "alter table xcontract drop picture_id",
        "create cached table xcontractpage"
        + "("
        + "    xcontractpage_id   int generated by default as identity (start with 1),"
        + "    xcontract_id       int not null,"
        + "    pagenum            int,"
        + "    description        varchar(64),"
        + "    pagescan           other,"
        + "    constraint xcontractpage_pk primary key (xcontractpage_id),"
        + "    constraint xcontractpage_xcontract_fk foreign key (xcontract_id) references xcontract on delete cascade"
        + ")",
        //version 0.4->0.5
        "create cached table xquotation ("
        + "    xquotation_id      int generated by default as identity (start with 1),"
        + "    xclient_id         int not null,"
        + "    rfcnumber          varchar(32) not null,"
        + "    constraint xquotation_pk primary key (xquotation_id),"
        + "    constraint xquotation_xclient_fk foreign key (xclient_id) references xclient"
        + ")",
        "create cached table xquotationpage ("
        + "    xquotationpage_id  int generated by default as identity (start with 1),"
        + "    xquotation_id      int not null,"
        + "    pagenum            int,"
        + "    description        varchar(64),"
        + "    pagescan           other," 
        + "    constraint xquotationpage_pk primary key (xquotationpage_id),"
        + "    constraint xquotationpage_xquotation_fk foreign key (xquotation_id) references xquotation on delete cascade"
        +")",
        "create cached table xorder ("
        + "    xorder_id          int generated by default as identity (start with 1),"
        + "    xclient_id         int not null,"
        + "    xcontract_id       int,"
        + "     xquotation_id      int,"
        + "    vatnumber          varchar(32) not null,"
        + "    regnumber          varchar(32) not null,"
        + "    ordernumber        varchar(32) not null,"
        + "    orderdate          date not null,"
        + "    contactname        varchar(255),"
        + "    contactphone       varchar(32),"
        + "    contactfax         varchar(32),"
        + "    deliveryaddress    varchar(255) not null,"
        + "    invoiceaddress     varchar(255) not null,"
        + "    constraint xorder_pk primary key (xorder_id),"
        + "    constraint xorder_xclient_fk foreign key (xclient_id) references xclient,"
        + "    constraint xorder_xquotation_fk  foreign key (xquotation_id) references xquotation,"
        + "    constraint xorder_xcontract foreign key (xcontract_id) references xcontract"
        + ")",
        "create cached table xorderitem ("
        + "    xorderitem_id     int generated by default as identity (start with 1),"
        + "    xorder_id         int not null,"
        + "    itemnumber        varchar(16) not null,"
        + "    materialnumber    varchar(16),"
        + "    description       varchar(255) not null,"
        + "    quantity          int not null,"
        + "    measureitem       varchar(8),"
        + "    priceperone       decimal(10,2) not null,"
        + "    constraint xorderitem_pk primary key (xorderitem_id),"
        + "    constraint xoreritem_xorder_fk foreign key (xorder_id) references xorder on delete cascade"
        + ")",
        "create cached table xorderpage ("
        + "     xorderpage_id     int generated by default as identity (start with 1),"
        + "     xorder_id         int not null,"
        + "     pagenum           int,"
        + "     description       varchar(64),"
        + "     pagescan          other,"
        + "     constraint xorderpage_pk primary key (xorderpage_id),"
        + "     constraint xorderpage_xorder_fk foreign key (xorder_id) references xorder on delete cascade"
        + ");",
        //version 0.5->0.6
        "alter table xorderitem add machinetype varchar(64)",
        "alter table xorderitem add deliveryreq date",
        "alter table xorderitem add delivery date",
        "alter table xorderitem modify measureitem varchar(16),"
    };

    public static Connection getConnection() throws RemoteException {
        Connection connection = null;
        try {
            Locale.setDefault(Locale.ENGLISH);
            DriverManager.registerDriver(
                    (java.sql.Driver) Class.forName(
                    props.getProperty("dbDriverName",
                    "org.hsqldb.jdbcDriver")).newInstance());
            connection = DriverManager.getConnection(
                    props.getProperty("dbConnection",
                    "jdbc:hsqldb:file://" + getCurDir() + "/DB/XlendServer"),
                    props.getProperty("dbUser", "sa"),
                    props.getProperty("dbPassword", ""));
            connection.setAutoCommit(true);
        } catch (Exception e) {
            XlendServer.log(e);
        }
        if (isFirstTime && props.getProperty("dbDriverName", "org.hsqldb.jdbcDriver").equals("org.hsqldb.jdbcDriver")) {
            initLocalDB(connection);
            fixLocalDB(connection);
            isFirstTime = false;
        }
        return checkVersion(connection);
    }

    public static void initLocalDB(Connection connection) {
        sqlBatch(createLocalDBsqls, connection, false);
    }

    public static void fixLocalDB(Connection connection) {
        sqlBatch(fixLocalDBsqls, connection, props.getProperty("LogDbFixes", "false").equalsIgnoreCase("true"));
    }

    private static void sqlBatch(String[] sqls, Connection connection, boolean tolog) {
        PreparedStatement ps = null;
        for (int i = 0; i < sqls.length; i++) {
            try {
                ps = connection.prepareStatement(sqls[i]);
                ps.execute();
                if (tolog) {
                    XlendServer.log("STATEMENT [" + sqls[i].substring(0, 
                            sqls[i].length() > 60 ? 60 : sqls[i].length()) + "]... processed");
                }
            } catch (SQLException e) {
                if (tolog) {
                    XlendServer.log(e);
                }
            } finally {
                try {
                    ps.close();
                } catch (SQLException ex) {
                }
            }
        }
    }

    public static void setProps(Properties props) {
        DbConnection.props = props;
    }

    public static void closeConnection(Connection connection) throws SQLException {
        connection.commit();
        connection.close();
        connection = null;
    }

    private static String getCurDir() {
        File curdir = new File("./");
        return curdir.getAbsolutePath();
    }

    private static Connection checkVersion(Connection connection) throws RemoteException {
        PreparedStatement ps = null;
        ResultSet rs = null;
        String err;
        String stmt = "SELECT version_id,version FROM dbversion WHERE dbversion_id=1";
        int curversion_id = 0;
        String curversion = "0.0";
        try {
            ps = connection.prepareStatement(stmt);
            rs = ps.executeQuery();
            if (rs.next()) {
                curversion_id = rs.getInt(1);
                curversion = rs.getString(2);
            }
            if (DB_VERSION_ID > curversion_id || !curversion.equals(DB_VERSION)) {
                err = "Invalid database version! " + "expected:" + DB_VERSION + "(" + DB_VERSION_ID + ") "
                        + "found:" + curversion + "(" + curversion_id + ")";
                XlendServer.log(err);
                throw new RemoteException(err);
            }
        } catch (SQLException ex) {
            XlendServer.log(ex);
            try {
                closeConnection(connection);
            } catch (SQLException ex1) {
            }
        } finally {
            try {
                if (rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException ex) {
                    }
                }
            } finally {
                if (ps != null) {
                    try {
                        ps.close();
                    } catch (SQLException ex) {
                    }
                }
            }
        }
        return connection;
    }

//    public static void shutDownDatabase() {
//        Connection connection = null;
//        try {
//            connection = getConnection();
//            sqlBatch(new String[]{"sрutdown"}, connection, true);
//        } catch (RemoteException ex) {
//            XlendServer.log(ex);
//        } finally {
//            try {
//                closeConnection(connection);
//            } catch (SQLException ex1) {
//            }
//        }
//    }
    private static String[] loadDDLscript(String fname) {
        String[] ans = new String[0];
        File sqlFile = new File(fname);
        boolean toclean = true;
        if (!sqlFile.exists()) {
            fname = "../sql/" + fname;
            sqlFile = new File(fname);
            toclean = false;
        }
        if (sqlFile.exists()) {
            StringBuffer contents = new StringBuffer();
            java.io.BufferedReader reader = null;
            try {
                reader = new java.io.BufferedReader(new FileReader(sqlFile));
                String line = null;
                int lineNum = 0;
                while ((line = reader.readLine()) != null) {
                    int cut = line.indexOf("--");
                    if (cut >= 0) {
                        line = line.substring(0, cut);
                    }
                    contents.append(line).append(System.getProperty("line.separator"));
                }
                ans = contents.toString().split(";");
            } catch (Exception e) {
                XlendServer.log(e);
            } finally {
                try {
                    if (reader != null) {
                        reader.close();
                    }
                } catch (IOException ie) {
                }
            }
            if (toclean) {
                sqlFile.delete();
            }
        } else {
            XlendServer.log("File " + fname + " not found");
        }
        return ans;
    }
}
